#include<stdio.h>
#define n 11	//顶点个数 
int b[11][11]={
0,28,10000,10000,10000,10000,28,10000,10000,10000,10000,
28,0,14,10000,48,76,10000,10000,10000,10000,10000,
10000,14,0,31,10000,10000,10000,10000,10000,10000,10000,
10000,10000,31,0,14,10000,10000,10000,10000,10000,10000,
10000,48,10000,14,0,38,10000,10000,10000,10000,10000,
10000,76,10000,10000,38,0,10000,10000,10000,10000,17,
28,10000,10000,10000,10000,10000,0,10000,10000,10000,70,
10000,10000,10000,10000,10000,10000,10000,0,31,74,10000,
10000,10000,10000,10000,10000,10000,10000,31,0,33,39,
10000,10000,10000,10000,10000,10000,10000,74,33,0,10000,
10000,10000,10000,10000,10000,17,70,10000,39,10000,0};	               //临界矩阵

int lujing[11]={0};

void Dijkstra(int v,int z)
{
	int dist[11];                      //存储最短路径的长度值
	int pre[11];                       //存储一个顶点在其最短路径的前趋
	int S[11];							//标志数组，若为已经找到最短路径的结点则为1,否则为0
	int q[11];                         //存储逆序路径 
	int m=0,l=0; 
	for(int i=0;i<n;i++)
	{
		dist[i]=b[v-1][i];        //初始化
		S[i]=0;                    //标志位初始为0
		if(dist[i]<10000)
			pre[i]=v-1;              //若存在边，则前趋为原点
		else
			pre[i]=-1;             //否则，前趋为-1,不可达
	}
	S[v-1]=1;                        //原点标志为1    
	for(int i=0;i<n-1;i++)
	{        //循环n-1次
		int u;                     //u为待选顶点
		int min=10000;         
		for(int j=0;j<n;j++)
		{
			if((!S[j])&&dist[j]<min)
			{ //寻找距离S最小的顶点u
				min=dist[j];
				u=j;
			}
		}
		S[u]=1;                    //将其标志设置为1
		for(int k=0;k<n;k++)
		{      //调整未加入S的点的的距离值
			if((!S[k])&&dist[k]>dist[u]+b[u][k])
			{
				dist[k]=dist[u]+b[u][k];
				pre[k]=u;          //若通过u减小了k的距离，则修改k的前趋为u
			}
		}
	}
	//printf("\nThe result:\n");     //输出结果
	for(int i=0;i<n;i++)
	{
		if(i==z-1)
		{
			//printf("<%d,%d>:  ",v,z);
			int p=pre[i];  
			if(p!=-1)
			{                 //若可达输出最短路径
				//printf("%d  ",dist[i]);    //输出最短距离
				//printf("%d",z);      //根据前趋逆向输出最短路径
				q[m++]=z;
				while(p!=v-1)
				{
					q[m++]=p+1;
					//printf("<--%d",p+1);
					p=pre[p];
				}
				q[m]=v;
				//printf("<--%d",v);
			}
			/*else
			{                      //若不可达则输出“inf”
				printf("inf");
			}
			printf("\n");*/
		}
		
	}
	while(m>=0)
	{
		lujing[l++]=q[m];
		m--;
	}
}

int main()
{
	int v=7;
	int z=3;
	int l=0;
	Dijkstra(v,z);
	while(lujing[l]!=0)
		{
			printf("%d\t",lujing[l]);
			l++;
		}                   //以顶点1（即下标为0）为原点v
	return 0;
}
